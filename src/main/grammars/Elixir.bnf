{
  parserClass="dev.murek.elixirij.lang.parser.ExParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  
  psiClassPrefix="Ex"
  psiImplClassSuffix="Impl"
  psiPackage="dev.murek.elixirij.lang.psi"
  psiImplPackage="dev.murek.elixirij.lang.psi.impl"
  
  elementTypeHolderClass="dev.murek.elixirij.lang.psi.ExTypes"
  elementTypeClass="dev.murek.elixirij.lang.psi.ExElementType"
  tokenTypeClass="dev.murek.elixirij.lang.psi.ExTokenType"
  
  // Use tokens from ElementTypes.kt
  generate=[tokens="no"]
  parserImports=[
    "static dev.murek.elixirij.lang.ElementTypes.*"
    "static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  ]
  
  tokens = [
    space='regexp:\s+'
    comment='regexp:#[^\r\n]*'
  ]
  
  // Expression hierarchy - all expression types extend from expression
  extends(".*Expr")=expression
  extends("literal|atom|identifier|alias|list|tuple|map|struct|bitstring|sigil|heredoc|charlistHeredoc|parenExpr|doBlock|noParensCall")=expression
  
  // Named rules for binary operators (for better PSI structure)
  name("stabExpr")="stab expression"
  name("inMatchExpr")="in-match expression"
  name("whenExpr")="when expression"
  name("typeExpr")="type expression"
  name("pipeExpr")="pipe expression"
}

// Root rule
root ::= topLevelExpressions

topLevelExpressions ::= (eoe? expression (eoe expression)*)? eoe? {
  pin=1
}

// End of expression: newlines or semicolons
private eoe ::= (EX_EOL | EX_SEMICOLON)+

// =============================================================================
// Expression hierarchy - following operator precedence (lowest to highest)
// The parser will try these in order, producing the correct precedence
// =============================================================================

// Using fake rule to define expression base type
expression ::= stabExpr

// Container expression: used inside lists, maps, tuples, bitstrings where | and :: have special meaning
// Starts from matchExpr to skip stab, inMatch, when, type, and pipe operators
private containerExpr ::= matchExpr

// Precedence 10: -> (right associative) - stab operator
stabExpr ::= inMatchExpr (EX_ARROW stabExpr)?

// Precedence 40: <-, \\ (left associative) - in-match operators
inMatchExpr ::= whenExpr (inMatchOp whenExpr)*
private inMatchOp ::= EX_LEFT_ARROW | EX_BACK_SLASH_BACK_SLASH

// Precedence 50: when (right associative)
whenExpr ::= typeExpr (EX_WHEN whenExpr)?

// Precedence 60: :: (right associative) - type operator
typeExpr ::= pipeExpr (EX_COLON_COLON typeExpr)?

// Precedence 70: | (right associative) - pipe operator for patterns
pipeExpr ::= matchExpr (EX_PIPE pipeExpr)?

// Precedence 100: = (right associative)
matchExpr ::= orExpr (EX_EQ matchExpr)?

// Precedence 120: ||, |||, or (left associative)
orExpr ::= andExpr (orOp andExpr)*
private orOp ::= EX_PIPE_PIPE | EX_PIPE_PIPE_PIPE | EX_OR

// Precedence 130: &&, &&&, and (left associative)
andExpr ::= compExpr (andOp compExpr)*
private andOp ::= EX_AMP_AMP | EX_AMP_AMP_AMP | EX_AND

// Precedence 140: ==, !=, =~, ===, !== (left associative)
compExpr ::= relExpr (compOp relExpr)*
private compOp ::= EX_EQ_EQ | EX_NOT_EQ | EX_EQ_TILDE | EX_EQ_EQ_EQ | EX_NOT_EQ_EQ

// Precedence 150: <, >, <=, >= (left associative)
relExpr ::= arrowExpr (relOp arrowExpr)*
private relOp ::= EX_LT_EQ | EX_GT_EQ | EX_LT | EX_GT

// Precedence 160: |>, <<<, >>>, <<~, ~>>, <~, ~>, <~>, <|> (left associative)
arrowExpr ::= inExpr (arrowOp inExpr)*
private arrowOp ::= EX_PIPE_GT | EX_LT_LT_LT | EX_GT_GT_GT | EX_LT_LT_TILDE | EX_TILDE_GT_GT | EX_LT_TILDE | EX_TILDE_GT | EX_LT_TILDE_GT | EX_LT_PIPE_GT

// Precedence 170: in, not in (left associative)
inExpr ::= xorExpr (inOp xorExpr)*
private inOp ::= EX_NOT EX_IN | EX_IN

// Precedence 190: // (right associative) - ternary/default operator
xorExpr ::= concatExpr (EX_SLASH_SLASH xorExpr)?

// Precedence 200: ++, --, +++, ---, <>, .. (right associative)
concatExpr ::= rangeExpr (concatOp concatExpr)?
private concatOp ::= EX_PLUS_PLUS_PLUS | EX_MINUS_MINUS_MINUS | EX_PLUS_PLUS | EX_MINUS_MINUS | EX_LT_GT

// Range operator: .. and ..// (right associative)
rangeExpr ::= dualExpr (rangeOp rangeExpr)?
private rangeOp ::= EX_DOT_DOT_SLASH_SLASH | EX_DOT_DOT

// Precedence 210: +, - binary (left associative)
dualExpr ::= multExpr (dualOp multExpr)*
private dualOp ::= EX_PLUS | EX_MINUS

// Precedence 220: *, / (left associative)
multExpr ::= powerExpr (multOp powerExpr)*
private multOp ::= EX_STAR | EX_SLASH

// Precedence 230: ** (left associative)
powerExpr ::= unaryExpr (EX_STAR_STAR unaryExpr)*

// Precedence 300: Unary operators (right associative / prefix)
unaryExpr ::= unaryOp unaryExpr | captureExpr
private unaryOp ::= EX_NOT | EX_EXCLAMATION | EX_CARET | EX_TILDE | EX_PLUS | EX_MINUS

// Capture operator: & (for &func/arity and &(&1 + &2))
captureExpr ::= captureNamedExpr | captureAnonymousExpr | capturePlaceholderExpr | captureBareExpr | atExpr
captureNamedExpr ::= EX_AMPERSAND captureTarget EX_SLASH EX_INTEGER
captureAnonymousExpr ::= EX_AMPERSAND parenExpr
capturePlaceholderExpr ::= EX_AMPERSAND EX_INTEGER
private captureBareExpr ::= EX_AMPERSAND captureTarget
private captureTarget ::= (atom | alias | identifier) (EX_DOT identifier)*

// Module attributes
moduleAttr ::= EX_AT identifier attrValue?
private attrValue ::= expression

// @ operator (module attributes)
atExpr ::= moduleAttr | noParensCall | accessExpr

// Precedence 310: Dot access and calls (left associative)
// Access expression includes primary expressions, dot access, bracket access, and function calls
accessExpr ::= primaryExpr accessSuffix*
private accessSuffix ::= dotAccess | anonymousCall | bracketAccess | parenCall

// No-parens function call: func arg1, arg2
noParensCall ::= !literal callTarget &noParensArgStart noParensArgs doBlock?
private callTarget ::= accessExpr
private noParensArgStart ::= !EX_DO (keywordPair | expression)
private noParensArgs ::= noParensKeywordArgs | noParensPositionalArgs
private noParensKeywordArgs ::= keywordPair (EX_COMMA keywordPair)*
private noParensPositionalArgs ::= expression (EX_COMMA expression)* keywordTail?
private keywordTail ::= EX_COMMA keywordPair (EX_COMMA keywordPair)*

// Dot access: expr.field or Mod.Func
dotAccess ::= EX_DOT &dotTarget dotTarget
private dotTarget ::= identifier | alias

// Anonymous call: func.()
anonymousCall ::= EX_DOT &EX_LPAREN EX_LPAREN callArgs? EX_RPAREN

// Bracket access: expr[key]
bracketAccess ::= EX_LBRACKET containerExpr EX_RBRACKET { pin=1 }

// Parenthesized function call: func(args)
parenCall ::= EX_LPAREN callArgs? EX_RPAREN doBlock? { pin=1 }

// =============================================================================
// Primary expressions
// =============================================================================

private primaryExpr ::= literal
                      | atom
                      | identifier
                      | alias
                      | list
                      | tuple
                      | map
                      | struct
                      | bitstring
                      | sigil
                      | heredoc
                      | charlistHeredoc
                      | defmoduleExpr
                      | defExpr
                      | defmacroExpr
                      | defguardExpr
                      | defstructExpr
                      | defexceptionExpr
                      | defprotocolExpr
                      | defimplExpr
                      | importExpr
                      | requireExpr
                      | useExpr
                      | aliasDirective
                      | forExpr
                      | quoteExpr
                      | unquoteExpr
                      | unquoteSplicingExpr
                      | raiseExpr
                      | throwExpr
                      | sendExpr
                      | superExpr
                      | fnExpr
                      | caseExpr
                      | condExpr
                      | withExpr
                      | tryExpr
                      | receiveExpr
                      | doBlock
                      | parenExpr

// Parenthesized expression
parenExpr ::= EX_LPAREN expression? EX_RPAREN { pin=1 }

// Module definitions: defmodule MyApp.Module do ... end
defmoduleExpr ::= EX_DEFMODULE alias doBlock { pin=1 }

// Function definitions: def/defp
defExpr ::= (EX_DEF | EX_DEFP) defHead defBody { pin=1 }
private defHead ::= identifier defArgs? whenClause?
private defArgs ::= EX_LPAREN argList? EX_RPAREN
private defBody ::= doBlock | doInline
private doInline ::= EX_COMMA keywordList

// Macro definitions: defmacro/defmacrop
defmacroExpr ::= (EX_DEFMACRO | EX_DEFMACROP) defHead defBody { pin=1 }

// Guard definitions: defguard/defguardp
defguardExpr ::= (EX_DEFGUARD | EX_DEFGUARDP) identifier defArgs? whenClause { pin=1 }

// Struct and exception definitions
defstructExpr ::= EX_DEFSTRUCT (list | keywordList) { pin=1 }
defexceptionExpr ::= EX_DEFEXCEPTION (list | keywordList) { pin=1 }

// Protocol definitions
defprotocolExpr ::= EX_DEFPROTOCOL alias doBlock { pin=1 }
defimplExpr ::= EX_DEFIMPL alias EX_COMMA EX_FOR_COLON alias doBlock { pin=1 }

// Import/require/use
importExpr ::= EX_IMPORT alias importOpts? { pin=1 }
private importOpts ::= EX_COMMA keywordList
requireExpr ::= EX_REQUIRE alias { pin=1 }
useExpr ::= EX_USE alias useOpts? { pin=1 }
private useOpts ::= EX_COMMA keywordList

// Alias directive
aliasDirective ::= EX_ALIAS_KW alias (aliasMultiTail | aliasOpts)? { pin=1 }
private aliasMultiTail ::= EX_DOT EX_LBRACE alias (EX_COMMA alias)* EX_RBRACE
private aliasOpts ::= EX_COMMA EX_AS_COLON alias

// Comprehensions
forExpr ::= EX_FOR forClause (EX_COMMA forClause)* forOpts? doBlock { pin=1 }
private forClause ::= forGenerator | forFilter
private forGenerator ::= expression EX_LEFT_ARROW expression
private forFilter ::= expression
private forOpts ::= EX_COMMA (EX_INTO_COLON | EX_UNIQ_COLON | EX_REDUCE_COLON) expression

// Quote and unquote
quoteExpr ::= EX_QUOTE quoteOpts? doBlock { pin=1 }
private quoteOpts ::= EX_COMMA keywordList
unquoteExpr ::= EX_UNQUOTE EX_LPAREN expression EX_RPAREN { pin=1 }
unquoteSplicingExpr ::= EX_UNQUOTE_SPLICING EX_LPAREN expression EX_RPAREN { pin=1 }

// Raise, throw, send, super
raiseExpr ::= EX_RAISE expression (EX_COMMA expression)? { pin=1 }
throwExpr ::= EX_THROW expression { pin=1 }
sendExpr ::= EX_SEND expression EX_COMMA expression { pin=1 }
superExpr ::= EX_SUPER superArgs? { pin=1 }
private superArgs ::= EX_LPAREN callArgs? EX_RPAREN

// Anonymous function: fn -> end
fnExpr ::= EX_FN stabClause (eoe stabClause)* eoe? EX_END { pin=1 }
stabClause ::= stabParenClause | stabArgsClause | stabNoArgsClause
private stabParenClause ::= EX_LPAREN EX_RPAREN EX_ARROW stabBody { pin=1 }
private stabArgsClause ::= stabArgs EX_ARROW stabBody { pin=1 }
private stabNoArgsClause ::= EX_ARROW stabBody { pin=1 }
private stabArgs ::= stabArgList whenClause?
private stabArgList ::= stabArg (EX_COMMA stabArg)*
private stabArg ::= matchExpr
private stabBody ::= matchExpr (eoe matchExpr !EX_ARROW)*
private whenClause ::= EX_WHEN matchExpr

// Case expression: case expr do ... end
caseExpr ::= EX_CASE caseSubject EX_DO caseClauseList EX_END { pin=1 }
private caseSubject ::= expression &EX_DO
private caseClauseList ::= eoe? caseClause (eoe caseClause)* eoe?
private caseClause ::= stabClause

// Cond expression: cond do ... end
condExpr ::= EX_COND EX_DO condClauseList EX_END { pin=1 }
private condClauseList ::= eoe? condClause (eoe condClause)* eoe?
private condClause ::= matchExpr EX_ARROW matchExpr

// With expression: with ... do ... end
withExpr ::= EX_WITH withClause (EX_COMMA withClause)* doBlock { pin=1 }
private withClause ::= matchExpr EX_LEFT_ARROW withAccessExpr
private withAccessExpr ::= primaryExpr withAccessSuffix*
private withAccessSuffix ::= dotAccess | anonymousCall | bracketAccess | withParenCall
private withParenCall ::= EX_LPAREN callArgs? EX_RPAREN { pin=1 }

// Try expression: try do ... rescue/catch/after ... end
tryExpr ::= EX_TRY EX_DO tryContents EX_END { pin=1 }
private tryContents ::= doContents tryClauses
private tryClauses ::= eoe* rescueClause* eoe* catchClause* eoe* afterClause? eoe*

// Receive expression: receive do ... after ... end
receiveExpr ::= EX_RECEIVE EX_DO receiveClauseList receiveAfterClause? EX_END { pin=1 }
private receiveClauseList ::= eoe? receiveClause (eoe receiveClause)* eoe?
private receiveClause ::= stabClause
private receiveAfterClause ::= eoe* afterClause eoe*

// Do blocks: do ... end (with optional clauses)
doBlock ::= EX_DO doContents doBlockSuffix EX_END { pin=1 }
private doBlockSuffix ::= eoe* blockClauses? eoe*
private blockClauses ::= blockClause (eoe* blockClause)*
doContents ::= (eoeWithExpression* expression (eoeWithExpression expression)*)?
private eoeWithExpression ::= &(eoe expression) eoe
private blockClause ::= elseClause | afterClause | catchClause | rescueClause
private elseClause ::= EX_ELSE doContents
private afterClause ::= EX_AFTER doContents
private catchClause ::= EX_CATCH stabClauseList
private rescueClause ::= EX_RESCUE stabClauseList
private stabClauseList ::= eoe? stabClause (eoe stabClause)* eoe?

// =============================================================================
// Literals
// =============================================================================

literal ::= integer
          | float
          | char
          | string
          | charlist
          | booleanLiteral
          | nilLiteral

integer ::= EX_INTEGER
float ::= EX_FLOAT
char ::= EX_CHAR
string ::= EX_STRING
charlist ::= EX_CHARLIST
heredoc ::= EX_HEREDOC
charlistHeredoc ::= EX_CHARLIST_HEREDOC
sigil ::= EX_SIGIL

booleanLiteral ::= EX_TRUE | EX_FALSE
nilLiteral ::= EX_NIL

// =============================================================================
// Identifiers and atoms
// =============================================================================

identifier ::= EX_IDENTIFIER

alias ::= EX_ALIAS (EX_DOT EX_ALIAS)*

atom ::= EX_ATOM | EX_ATOM_QUOTED

// =============================================================================
// Data structures
// =============================================================================

// List: [1, 2, 3] or [a: 1, b: 2] or [h | t]
list ::= EX_LBRACKET listContents? EX_RBRACKET { pin=1 }
private listContents ::= listElement (EX_COMMA listElement)* EX_COMMA? (EX_PIPE containerExpr)?
                       | containerExpr EX_PIPE containerExpr
private listElement ::= keywordPair | containerExpr

// Keyword pair: key: value
keywordPair ::= keywordKey containerExpr
private keywordKey ::= EX_KW_IDENTIFIER | EX_FOR_COLON | EX_AS_COLON | EX_ATOM_QUOTED EX_COLON

// Tuple: {1, 2, 3}
tuple ::= EX_LBRACE tupleContents? EX_RBRACE { pin=1 }
private tupleContents ::= containerExpr (EX_COMMA containerExpr)* EX_COMMA?

// Map: %{key: value} or %{"key" => value}
map ::= EX_PERCENT_LBRACE mapContents? EX_RBRACE { pin=1 }
private mapContents ::= mapUpdateContents | mapPairContents
private mapUpdateContents ::= containerExpr EX_PIPE mapPairContents
private mapPairContents ::= mapPair (EX_COMMA mapPair)* EX_COMMA?
private mapPair ::= keywordPair | assocPair
assocPair ::= containerExpr EX_FAT_ARROW containerExpr

// Struct: %ModuleName{key: value}
struct ::= EX_PERCENT alias EX_LBRACE mapContents? EX_RBRACE { pin=1 }

// Bitstring: <<1, 2, 3>> or <<x::binary>>
bitstring ::= EX_LT_LT bitstringContents? EX_GT_GT { pin=1 }
private bitstringContents ::= bitstringElement (EX_COMMA bitstringElement)* EX_COMMA?
private bitstringElement ::= containerExpr bitstringType?
private bitstringType ::= EX_COLON_COLON bitstringTypeSpec (EX_MINUS bitstringTypeSpec)*
private bitstringTypeSpec ::= bitstringTypeName (EX_LPAREN containerExpr EX_RPAREN)?
private bitstringTypeName ::= EX_IDENTIFIER | EX_INTEGER

// =============================================================================
// Function call arguments
// =============================================================================

// Call arguments: comma-separated expressions or keyword pairs
private callArgs ::= callArg (EX_COMMA callArg)* EX_COMMA?
private callArg ::= keywordPair | containerExpr

// Argument list: used in function heads and guards
private argList ::= matchExpr (EX_COMMA matchExpr)* EX_COMMA?

// Keyword list: comma-separated keyword pairs
private keywordList ::= keywordPair (EX_COMMA keywordPair)* EX_COMMA?
