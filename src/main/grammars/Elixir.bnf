{
  parserClass="dev.murek.elixirij.lang.parser.ExParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  
  psiClassPrefix="Ex"
  psiImplClassSuffix="Impl"
  psiPackage="dev.murek.elixirij.lang.psi"
  psiImplPackage="dev.murek.elixirij.lang.psi.impl"
  
  elementTypeHolderClass="dev.murek.elixirij.lang.psi.ExTypes"
  elementTypeClass="dev.murek.elixirij.lang.psi.ExElementType"
  tokenTypeClass="dev.murek.elixirij.lang.psi.ExTokenType"
  
  // Use tokens from ElementTypes.kt
  generate=[tokens="no"]
  parserImports=[
    "static dev.murek.elixirij.lang.ElementTypes.*"
    "static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  ]
  
  tokens = [
    space='regexp:\s+'
    comment='regexp:#[^\r\n]*'
  ]
  
  // Expression hierarchy - all expression types extend from expression
  extends(".*Expr")=expression
  extends("literal|atom|identifier|alias|aliasMulti|list|tuple|map|struct|bitstring|sigil|heredoc|charlistHeredoc|parenExpr|doBlock")=expression
  
  // Named rules for binary operators (for better PSI structure)
  name("stabExpr")="stab expression"
  name("inMatchExpr")="in-match expression"
  name("whenExpr")="when expression"
  name("typeExpr")="type expression"
  name("pipeExpr")="pipe expression"
}

// Root rule
root ::= topLevelExpressions

topLevelExpressions ::= (eoe? topLevelExpression (eoe topLevelExpression)*)? eoe? {
  pin=1
}
private topLevelExpression ::= bareDoCall | expression { recoverWhile=topLevelRecovery }

// End of expression: newlines or semicolons
private eoe ::= (EX_EOL | EX_SEMICOLON)+
private opSep ::= (EX_EOL | EX_COMMENT)*
private topLevelRecovery ::= !(EX_EOL | EX_SEMICOLON)
private doRecovery ::= !(EX_ELSE | EX_AFTER | EX_CATCH | EX_RESCUE | EX_END | EX_EOL)
private listRecovery ::= !(EX_COMMA | EX_RBRACKET | EX_PIPE | EX_EOL)
private tupleRecovery ::= !(EX_COMMA | EX_RBRACE)
private mapRecovery ::= !(EX_COMMA | EX_RBRACE | EX_EOL)
private bitstringRecovery ::= !(EX_COMMA | EX_GT_GT)
private callArgRecovery ::= !(EX_COMMA | EX_RPAREN)
private keywordPairRecovery ::= !(EX_COMMA | EX_RBRACKET | EX_RBRACE | EX_RPAREN | EX_END)

// =============================================================================
// Expression hierarchy - following operator precedence (lowest to highest)
// The parser will try these in order, producing the correct precedence
// =============================================================================

// Using fake rule to define expression base type
expression ::= stabExpr

// Container expression: used inside lists, maps, tuples, bitstrings where | and :: have special meaning
// Starts from matchExpr to skip stab, inMatch, when, type, and pipe operators
private containerExpr ::= matchExpr

// Precedence 10: -> (right associative) - stab operator
stabExpr ::= inMatchExpr (EX_ARROW opSep stabExpr)?

// Precedence 40: <-, \\ (left associative) - in-match operators
inMatchExpr ::= whenExpr (inMatchOp opSep whenExpr)*
private inMatchOp ::= EX_LEFT_ARROW | EX_BACK_SLASH_BACK_SLASH

// Precedence 50: when (right associative)
whenExpr ::= typeExpr (EX_WHEN opSep whenExpr)?

// Precedence 60: :: (right associative) - type operator
typeExpr ::= pipeExpr (EX_COLON_COLON opSep typeExpr)?

// Precedence 70: | (right associative) - pipe operator for patterns
pipeExpr ::= matchExpr (EX_PIPE opSep pipeExpr)?

// Precedence 100: = (right associative)
matchExpr ::= orExpr (EX_EQ opSep matchExpr)?

// Precedence 120: ||, |||, or (left associative)
orExpr ::= andExpr (orOp opSep andExpr)*
private orOp ::= EX_PIPE_PIPE | EX_PIPE_PIPE_PIPE | EX_OR

// Precedence 130: &&, &&&, and (left associative)
andExpr ::= compExpr (andOp opSep compExpr)*
private andOp ::= EX_AMP_AMP | EX_AMP_AMP_AMP | EX_AND

// Precedence 140: ==, !=, =~, ===, !== (left associative)
compExpr ::= relExpr (compOp opSep relExpr)*
private compOp ::= EX_EQ_EQ | EX_NOT_EQ | EX_EQ_TILDE | EX_EQ_EQ_EQ | EX_NOT_EQ_EQ

// Precedence 150: <, >, <=, >= (left associative)
relExpr ::= arrowExpr (relOp opSep arrowExpr)*
private relOp ::= EX_LT_EQ | EX_GT_EQ | EX_LT | EX_GT

// Precedence 160: |>, <<<, >>>, <<~, ~>>, <~, ~>, <~>, <|> (left associative)
arrowExpr ::= inExpr (opSep &arrowOp arrowOp opSep inExpr)*
private arrowOp ::= EX_PIPE_GT | EX_LT_LT_LT | EX_GT_GT_GT | EX_LT_LT_TILDE | EX_TILDE_GT_GT | EX_LT_TILDE | EX_TILDE_GT | EX_LT_TILDE_GT | EX_LT_PIPE_GT

// Precedence 170: in, not in (left associative)
inExpr ::= xorExpr (inOp opSep xorExpr)*
private inOp ::= EX_NOT EX_IN | EX_IN

// Precedence 190: // (right associative) - ternary/default operator
xorExpr ::= concatExpr (EX_SLASH_SLASH opSep xorExpr)?

// Precedence 200: ++, --, +++, ---, <>, .. (right associative)
concatExpr ::= rangeExpr (concatOp opSep concatExpr)?
private concatOp ::= EX_PLUS_PLUS_PLUS | EX_MINUS_MINUS_MINUS | EX_PLUS_PLUS | EX_MINUS_MINUS | EX_LT_GT

// Range operator: .. and ..// (right associative)
rangeExpr ::= dualExpr (rangeOp opSep rangeExpr)?
private rangeOp ::= EX_DOT_DOT_SLASH_SLASH | EX_DOT_DOT

// Precedence 210: +, - binary (left associative)
dualExpr ::= multExpr (dualOp opSep multExpr)*
private dualOp ::= EX_PLUS | EX_MINUS

// Precedence 220: *, / (left associative)
multExpr ::= powerExpr (multOp opSep powerExpr)*
private multOp ::= EX_STAR | EX_SLASH

// Precedence 230: ** (left associative)
powerExpr ::= unaryExpr (EX_STAR_STAR opSep unaryExpr)*

// Precedence 300: Unary operators (right associative / prefix)
unaryExpr ::= unaryOp unaryExpr | callExpr | captureExpr | primaryExpr
private unaryOp ::= EX_NOT | EX_EXCLAMATION | EX_CARET | EX_TILDE | EX_PLUS | EX_MINUS

// Capture operator: & (for &func/arity and &(&1 + &2))
captureExpr ::= captureNamedExpr | capturePlaceholderAccessExpr | capturePlaceholderExpr | captureBareExpr | captureAnonymousExpr | atExpr
captureNamedExpr ::= EX_AMPERSAND captureTarget EX_SLASH EX_INTEGER
private capturePlaceholderAccessExpr ::= EX_AMPERSAND EX_INTEGER placeholderSuffix+
capturePlaceholderExpr ::= EX_AMPERSAND EX_INTEGER
private captureBareExpr ::= EX_AMPERSAND captureTarget !EX_LPAREN
captureAnonymousExpr ::= EX_AMPERSAND (callExpr | parenExpr | accessExpr)
private captureTarget ::= (atom | alias | identifier) (EX_DOT identifier)*

// Module attributes
moduleAttr ::= EX_AT identifier attrValue?
private attrValue ::= expression | keywordList

// @ operator (module attributes)
atExpr ::= moduleAttr | accessExpr

// Precedence 310: Dot access and calls (left associative)
// Access expression includes primary expressions, capture placeholders, dot access, bracket access, and function calls
accessExpr ::= accessBase &accessSuffixStart accessSuffix+
private accessBase ::= accessPrimaryExpr | capturePlaceholderExpr
private accessSuffix ::= dotAccess | bracketAccess
private accessSuffixStart ::= EX_DOT | EX_LBRACKET

// No-parens function call: func arg1, arg2
private noParensCall ::= !literal callTarget !EX_LPAREN ((&noParensArgStart noParensArgs doBlock?) | doBlock)

callExpr ::= noParensCall | bareDoCall | parenCallChain | anonymousCallChain
private parenCallChain ::= callBaseNoParen callAccessSuffix* parenCall callChainTail doBlock?
private anonymousCallChain ::= callBase callAccessSuffix* anonymousCall callChainTail doBlock?
private callChainTail ::= (callAccessSuffix* callInvocationSuffix)* callAccessSuffix*
private callInvocationSuffix ::= parenCall | anonymousCall
private callAccessSuffix ::= dotAccess | bracketAccess
private callBase ::= accessExpr | accessPrimaryExpr | capturePlaceholderExpr
private callBaseNoParen ::= accessExpr | accessPrimaryExprNoParen | capturePlaceholderExpr

// Bare do-block call: func do ... end (no arguments before do-block)
// This is only valid at statement level, not inside expressions
private bareDoCall ::= !literal bareDoCallTarget doBlock
private bareDoCallTarget ::= (identifier | alias) (EX_DOT identifier)*
private callTarget ::= atom | identifier | alias | keywordCallTarget | accessExpr
private noParensArgStart ::= !EX_DO (keywordPairItem | expression)
private noParensArgs ::= noParensKeywordArgs | noParensPositionalArgs
private noParensKeywordArgs ::= keywordPairItem (EX_COMMA eoe* keywordPairItem)*
private noParensPositionalArgs ::= expression (EX_COMMA eoe* expression)* keywordTail?
private keywordTail ::= EX_COMMA eoe* keywordPairItem (EX_COMMA eoe* keywordPairItem)*
private keywordCallTarget ::= EX_RAISE | EX_THROW | EX_SEND | EX_SUPER

// Dot access: expr.field or Mod.Func
dotAccess ::= EX_DOT &dotTarget dotTarget
private dotTarget ::= identifier | alias

// Anonymous call: func.()
private anonymousCall ::= EX_DOT &EX_LPAREN EX_LPAREN callArgs? EX_RPAREN

// Bracket access: expr[key]
bracketAccess ::= EX_LBRACKET containerExpr EX_RBRACKET { pin=1 }

// Parenthesized function call: func(args)
private parenCall ::= EX_LPAREN opSep callArgs? opSep EX_RPAREN { pin=1 }

private placeholderSuffix ::= dotAccess | bracketAccess | parenCall | anonymousCall

// =============================================================================
// Primary expressions
// =============================================================================

private primaryExpr ::= literal
                      | atom
                      | aliasMulti
                      | alias
                      | list
                      | tuple
                      | map
                      | struct
                      | bitstring
                      | sigil
                      | heredoc
                      | charlistHeredoc
                      | fnExpr
                      | identifier
                      | doBlock
                      | typeArrowExpr
                      | parenExpr
                      | accessExpr
private accessPrimaryExpr ::= literal
                           | atom
                           | alias
                           | keywordCallTarget
                           | list
                           | tuple
                           | map
                           | struct
                           | bitstring
                           | sigil
                           | heredoc
                           | charlistHeredoc
                           | fnExpr
                           | identifier
                           | doBlock
                           | typeArrowExpr
                           | parenExpr

private accessPrimaryExprNoParen ::= literal
                                  | atom
                                  | alias
                                  | keywordCallTarget
                                  | list
                                  | tuple
                                  | map
                                  | struct
                                  | bitstring
                                  | sigil
                                  | heredoc
                                  | charlistHeredoc
                                  | fnExpr
                                  | identifier
                                  | doBlock
                                  | typeArrowExpr

// Parenthesized expression
parenExpr ::= EX_LPAREN expression? EX_RPAREN { pin=1 }

// Typespec function type: (args -> return)
private typeArrowExpr ::= EX_LPAREN opSep typeArrowArgs? opSep EX_ARROW opSep typeExpr opSep EX_RPAREN { pin=5 }
private typeArrowArgs ::= typeExpr (EX_COMMA opSep typeExpr)*

// Anonymous function: fn -> end
fnExpr ::= EX_FN eoe? stabClause (eoe stabClause)* eoe? EX_END { pin=1 }
stabClause ::= stabParenClause | stabArgsClause | stabNoArgsClause
private stabParenClause ::= EX_LPAREN EX_RPAREN EX_ARROW stabBody { pin=1 }
private stabArgsClause ::= stabArgs EX_ARROW stabBody { pin=1 }
private stabNoArgsClause ::= EX_ARROW stabBody { pin=1 }
private stabArgs ::= stabArgList whenClause?
private stabArgList ::= stabArg (EX_COMMA eoe* stabArg)*
private stabArg ::= matchExpr
private stabBody ::= eoe? matchExpr (eoe matchExpr !EX_ARROW)*
private whenClause ::= EX_WHEN matchExpr

// Do blocks: do ... end (with optional clauses)
doBlock ::= EX_DO doContents doBlockSuffix EX_END { pin=1 }
private doBlockSuffix ::= eoe* blockClauses? eoe*
private blockClauses ::= blockClause (eoe* blockClause)*
doContents ::= (eoeWithExpression* doExpression (eoeWithExpression doExpression)*)?
private eoeWithExpression ::= &(eoe expression) eoe
private doExpression ::= bareDoCall | expression { recoverWhile=doRecovery }
private blockClause ::= elseClause | afterClause | catchClause | rescueClause
private elseClause ::= EX_ELSE doContents
private afterClause ::= EX_AFTER doContents
private catchClause ::= EX_CATCH stabClauseList
private rescueClause ::= EX_RESCUE stabClauseList
private stabClauseList ::= eoe? stabClause (eoe stabClause)* eoe?

// =============================================================================
// Literals
// =============================================================================

literal ::= integer
          | float
          | char
          | string
          | charlist
          | booleanLiteral
          | nilLiteral

integer ::= EX_INTEGER
float ::= EX_FLOAT
char ::= EX_CHAR
string ::= EX_STRING
charlist ::= EX_CHARLIST
heredoc ::= EX_HEREDOC
charlistHeredoc ::= EX_CHARLIST_HEREDOC
sigil ::= EX_SIGIL

booleanLiteral ::= EX_TRUE | EX_FALSE
nilLiteral ::= EX_NIL

// =============================================================================
// Identifiers and atoms
// =============================================================================

identifier ::= EX_IDENTIFIER


alias ::= EX_ALIAS (EX_DOT EX_ALIAS)*
aliasMulti ::= EX_ALIAS EX_DOT EX_LBRACE opSep aliasMultiContents? opSep EX_RBRACE { pin=3 }
private aliasMultiContents ::= EX_ALIAS (EX_COMMA opSep EX_ALIAS)*

atom ::= EX_ATOM | EX_ATOM_QUOTED | atomAlias
private atomAlias ::= EX_COLON alias

// =============================================================================
// Data structures
// =============================================================================

// List: [1, 2, 3] or [a: 1, b: 2] or [h | t]
list ::= EX_LBRACKET opSep listContents? opSep EX_RBRACKET { pin=1 }
private listContents ::= opSep listElement (EX_COMMA opSep listElement)* EX_COMMA? opSep (EX_PIPE containerExpr)?
                       | containerExpr EX_PIPE containerExpr
private listElement ::= (keywordPairItem | containerExpr) { recoverWhile=listRecovery }

// Keyword pair: key: value
keywordPair ::= keywordKey opSep containerExpr
private keywordPairIncomplete ::= keywordKey { recoverWhile=keywordPairRecovery }
private keywordPairItem ::= keywordPair | keywordPairIncomplete
private keywordKey ::= EX_KW_IDENTIFIER | EX_ATOM_QUOTED EX_COLON | EX_STRING EX_COLON | EX_IDENTIFIER EX_COLON

// Tuple: {1, 2, 3}
tuple ::= EX_LBRACE opSep tupleContents? opSep EX_RBRACE { pin=1 }
private tupleContents ::= tupleElement (EX_COMMA opSep tupleElement)* EX_COMMA?
private tupleElement ::= (keywordPairItem | containerExpr) eoe* { recoverWhile=tupleRecovery }

// Map: %{key: value} or %{"key" => value}
map ::= EX_PERCENT_LBRACE opSep mapContents? opSep EX_RBRACE { pin=1 }
private mapContents ::= mapUpdateContents | mapPairContents
private mapUpdateContents ::= containerExpr EX_PIPE mapPairContents
private mapPairContents ::= opSep mapPair (EX_COMMA opSep mapPair)* EX_COMMA?
private mapPair ::= (keywordPairItem | assocPair) { recoverWhile=mapRecovery }
assocPair ::= containerExpr opSep EX_FAT_ARROW opSep containerExpr

// Struct: %ModuleName{key: value} or %module{key: value}
struct ::= EX_PERCENT structTarget EX_LBRACE mapContents? EX_RBRACE { pin=1 }
private structTarget ::= alias | identifier

// Bitstring: <<1, 2, 3>> or <<x::binary>>
bitstring ::= EX_LT_LT bitstringContents? EX_GT_GT { pin=1 }
private bitstringContents ::= bitstringElement (EX_COMMA bitstringElement)* EX_COMMA?
private bitstringElement ::= containerExpr bitstringType? { recoverWhile=bitstringRecovery }
private bitstringType ::= EX_COLON_COLON bitstringTypeSpec (EX_MINUS bitstringTypeSpec)*
private bitstringTypeSpec ::= bitstringTypeName (EX_LPAREN containerExpr EX_RPAREN)?
private bitstringTypeName ::= EX_IDENTIFIER | EX_INTEGER

// =============================================================================
// Function call arguments
// =============================================================================

// Call arguments: comma-separated expressions or keyword pairs
private callArgs ::= opSep? callArg (EX_COMMA opSep callArg)* (EX_COMMA opSep)? opSep?
private callArg ::= (keywordPairItem | expression) opSep? { recoverWhile=callArgRecovery }

// Argument list: used in function heads and guards
private argList ::= argListElement (EX_COMMA argListElement)* EX_COMMA?
private argListElement ::= (keywordPairItem | inMatchExpr) { recoverWhile=callArgRecovery }

// Keyword list: comma-separated keyword pairs
private keywordList ::= keywordPairItem (EX_COMMA eoe* keywordPairItem)* (EX_COMMA eoe*)?
