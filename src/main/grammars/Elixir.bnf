{
  parserClass="dev.murek.elixirij.lang.parser.ExParser"
  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
  
  psiClassPrefix="Ex"
  psiImplClassSuffix="Impl"
  psiPackage="dev.murek.elixirij.lang.psi"
  psiImplPackage="dev.murek.elixirij.lang.psi.impl"
  
  elementTypeHolderClass="dev.murek.elixirij.lang.psi.ExTypes"
  elementTypeClass="dev.murek.elixirij.lang.psi.ExElementType"
  tokenTypeClass="dev.murek.elixirij.lang.psi.ExTokenType"
  
  // Use tokens from ElementTypes.kt
  generate=[tokens="no"]
  parserImports=[
    "static dev.murek.elixirij.lang.ElementTypes.*"
    "static com.intellij.lang.parser.GeneratedParserUtilBase.*"
  ]
  
  tokens = [
    space='regexp:\s+'
    comment='regexp:#[^\r\n]*'
  ]
  
  // Expression hierarchy - all expression types extend from expression
  extends(".*Expr")=expression
  extends("literal|atom|identifier|alias|list|tuple|map|struct|bitstring|sigil|heredoc|charlistHeredoc|parenExpr")=expression
  
  // Named rules for binary operators (for better PSI structure)
  name("stabExpr")="stab expression"
  name("inMatchExpr")="in-match expression"
  name("whenExpr")="when expression"
  name("typeExpr")="type expression"
  name("pipeExpr")="pipe expression"
}

// Root rule
root ::= topLevelExpressions

topLevelExpressions ::= (eoe? expression (eoe expression)*)? eoe? {
  pin=1
}

// End of expression: newlines or semicolons
private eoe ::= (EX_EOL | EX_SEMICOLON)+

// =============================================================================
// Expression hierarchy - following operator precedence (lowest to highest)
// The parser will try these in order, producing the correct precedence
// =============================================================================

// Using fake rule to define expression base type
expression ::= stabExpr

// Container expression: used inside lists, maps, tuples, bitstrings where | and :: have special meaning
// Starts from matchExpr to skip stab, inMatch, when, type, and pipe operators
private containerExpr ::= matchExpr

// Precedence 10: -> (right associative) - stab operator
stabExpr ::= inMatchExpr (EX_ARROW stabExpr)?

// Precedence 40: <-, \\ (left associative) - in-match operators
inMatchExpr ::= whenExpr (inMatchOp whenExpr)*
private inMatchOp ::= EX_LEFT_ARROW | EX_BACK_SLASH_BACK_SLASH

// Precedence 50: when (right associative)
whenExpr ::= typeExpr (EX_WHEN whenExpr)?

// Precedence 60: :: (right associative) - type operator
typeExpr ::= pipeExpr (EX_COLON_COLON typeExpr)?

// Precedence 70: | (right associative) - pipe operator for patterns
pipeExpr ::= matchExpr (EX_PIPE pipeExpr)?

// Precedence 100: = (right associative)
matchExpr ::= orExpr (EX_EQ matchExpr)?

// Precedence 120: ||, |||, or (left associative)
orExpr ::= andExpr (orOp andExpr)*
private orOp ::= EX_PIPE_PIPE | EX_PIPE_PIPE_PIPE | EX_OR

// Precedence 130: &&, &&&, and (left associative)
andExpr ::= compExpr (andOp compExpr)*
private andOp ::= EX_AMP_AMP | EX_AMP_AMP_AMP | EX_AND

// Precedence 140: ==, !=, =~, ===, !== (left associative)
compExpr ::= relExpr (compOp relExpr)*
private compOp ::= EX_EQ_EQ | EX_NOT_EQ | EX_EQ_TILDE | EX_EQ_EQ_EQ | EX_NOT_EQ_EQ

// Precedence 150: <, >, <=, >= (left associative)
relExpr ::= arrowExpr (relOp arrowExpr)*
private relOp ::= EX_LT_EQ | EX_GT_EQ | EX_LT | EX_GT

// Precedence 160: |>, <<<, >>>, <<~, ~>>, <~, ~>, <~>, <|> (left associative)
arrowExpr ::= inExpr (arrowOp inExpr)*
private arrowOp ::= EX_PIPE_GT | EX_LT_LT_LT | EX_GT_GT_GT | EX_LT_LT_TILDE | EX_TILDE_GT_GT | EX_LT_TILDE | EX_TILDE_GT | EX_LT_TILDE_GT | EX_LT_PIPE_GT

// Precedence 170: in, not in (left associative)
inExpr ::= xorExpr (inOp xorExpr)*
private inOp ::= EX_NOT EX_IN | EX_IN

// Precedence 190: // (right associative) - ternary/default operator
xorExpr ::= concatExpr (EX_SLASH_SLASH xorExpr)?

// Precedence 200: ++, --, +++, ---, <>, .. (right associative)
concatExpr ::= rangeExpr (concatOp concatExpr)?
private concatOp ::= EX_PLUS_PLUS_PLUS | EX_MINUS_MINUS_MINUS | EX_PLUS_PLUS | EX_MINUS_MINUS | EX_LT_GT

// Range operator: .. and ..// (right associative)
rangeExpr ::= dualExpr (rangeOp rangeExpr)?
private rangeOp ::= EX_DOT_DOT_SLASH_SLASH | EX_DOT_DOT

// Precedence 210: +, - binary (left associative)
dualExpr ::= multExpr (dualOp multExpr)*
private dualOp ::= EX_PLUS | EX_MINUS

// Precedence 220: *, / (left associative)
multExpr ::= powerExpr (multOp powerExpr)*
private multOp ::= EX_STAR | EX_SLASH

// Precedence 230: ** (left associative)
powerExpr ::= unaryExpr (EX_STAR_STAR unaryExpr)*

// Precedence 300: Unary operators (right associative / prefix)
unaryExpr ::= unaryOp unaryExpr | captureExpr
private unaryOp ::= EX_NOT | EX_EXCLAMATION | EX_CARET | EX_TILDE | EX_PLUS | EX_MINUS

// Capture operator: & (for &func/arity and &(&1 + &2))
captureExpr ::= EX_AMPERSAND captureExpr | atExpr

// @ operator (module attributes)
atExpr ::= EX_AT atExpr | accessExpr

// Precedence 310: Dot access and calls (left associative)
// Access expression includes primary expressions, dot access, bracket access, and function calls
accessExpr ::= primaryExpr accessSuffix*
private accessSuffix ::= dotAccess | bracketAccess | parenCall

// Dot access: expr.field or Mod.Func
dotAccess ::= EX_DOT dotTarget { pin=1 }
private dotTarget ::= identifier | alias

// Bracket access: expr[key]
bracketAccess ::= EX_LBRACKET containerExpr EX_RBRACKET { pin=1 }

// Parenthesized function call: func(args)
parenCall ::= EX_LPAREN callArgs? EX_RPAREN { pin=1 }

// =============================================================================
// Primary expressions
// =============================================================================

private primaryExpr ::= literal
                      | atom
                      | identifier
                      | alias
                      | list
                      | tuple
                      | map
                      | struct
                      | bitstring
                      | sigil
                      | heredoc
                      | charlistHeredoc
                      | parenExpr

// Parenthesized expression
parenExpr ::= EX_LPAREN expression EX_RPAREN { pin=1 }

// =============================================================================
// Literals
// =============================================================================

literal ::= integer
          | float
          | char
          | string
          | charlist
          | booleanLiteral
          | nilLiteral

integer ::= EX_INTEGER
float ::= EX_FLOAT
char ::= EX_CHAR
string ::= EX_STRING
charlist ::= EX_CHARLIST
heredoc ::= EX_HEREDOC
charlistHeredoc ::= EX_CHARLIST_HEREDOC
sigil ::= EX_SIGIL

booleanLiteral ::= EX_TRUE | EX_FALSE
nilLiteral ::= EX_NIL

// =============================================================================
// Identifiers and atoms
// =============================================================================

identifier ::= EX_IDENTIFIER

alias ::= EX_ALIAS (EX_DOT EX_ALIAS)*

atom ::= EX_ATOM | EX_ATOM_QUOTED

// =============================================================================
// Data structures
// =============================================================================

// List: [1, 2, 3] or [a: 1, b: 2] or [h | t]
list ::= EX_LBRACKET listContents? EX_RBRACKET { pin=1 }
private listContents ::= listElement (EX_COMMA listElement)* EX_COMMA? (EX_PIPE containerExpr)?
                       | containerExpr EX_PIPE containerExpr
private listElement ::= keywordPair | containerExpr

// Keyword pair: key: value
keywordPair ::= keywordKey containerExpr
private keywordKey ::= EX_IDENTIFIER EX_COLON | EX_ATOM_QUOTED EX_COLON

// Tuple: {1, 2, 3}
tuple ::= EX_LBRACE tupleContents? EX_RBRACE { pin=1 }
private tupleContents ::= containerExpr (EX_COMMA containerExpr)* EX_COMMA?

// Map: %{key: value} or %{"key" => value}
map ::= EX_PERCENT_LBRACE mapContents? EX_RBRACE { pin=1 }
private mapContents ::= mapUpdateContents | mapPairContents
private mapUpdateContents ::= containerExpr EX_PIPE mapPairContents
private mapPairContents ::= mapPair (EX_COMMA mapPair)* EX_COMMA?
private mapPair ::= keywordPair | assocPair
assocPair ::= containerExpr EX_FAT_ARROW containerExpr

// Struct: %ModuleName{key: value}
struct ::= EX_PERCENT alias EX_LBRACE mapContents? EX_RBRACE { pin=1 }

// Bitstring: <<1, 2, 3>> or <<x::binary>>
bitstring ::= EX_LT_LT bitstringContents? EX_GT_GT { pin=1 }
private bitstringContents ::= bitstringElement (EX_COMMA bitstringElement)* EX_COMMA?
private bitstringElement ::= containerExpr bitstringType?
private bitstringType ::= EX_COLON_COLON bitstringTypeSpec (EX_MINUS bitstringTypeSpec)*
private bitstringTypeSpec ::= bitstringTypeName (EX_LPAREN containerExpr EX_RPAREN)?
private bitstringTypeName ::= EX_IDENTIFIER | EX_INTEGER

// =============================================================================
// Function call arguments
// =============================================================================

// Call arguments: comma-separated expressions
// TODO: Add proper support for keyword arguments (a: 1, b: 2)
// For now, we only support positional arguments
private callArgs ::= containerExpr (EX_COMMA containerExpr)* EX_COMMA?
